  // IS LEFT OF TWO IN A ROW
        public static Tuple<int, int> IsLeftofTwo(GameBoard_TPL<counters> board, counters us)
        {
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (board[x, y] == us && board[x, y] == board[x + xx, y + yy])
                                // two in a row in centre should give higher score
                                return new Tuple<int, int>(x, y);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS RIGHT OF THE TWO IN ROW
        public static Tuple<int, int> IsRightofTwo(GameBoard_TPL<counters> board, counters us)
        {
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (board[x, y] == us && board[x, y] == board[x + xx, y + yy])
                                // two in a row in centre should give higher score
                                return new Tuple<int, int>(x + xx, y + yy);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // FIND HORZI GAP BETWEEN TWO IN A ROW
        public bool FindTwoInARowWithAHorziGap(GameBoard_TPL<counters> board, counters us)
        {
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (board[x, y] == us && board[x, y] == board[x + xx + 1, y + yy])
                                // two in a row in centre should give higher score
                                return true;
                        }
                }
            return false;
        }
        // FIND VERTICAL GAP BETWEEN TWO IN A ROW
        public bool FindTwoInARowWithAVerticalGap(GameBoard_TPL<counters> board, counters us)
        {
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (board[x, y] == us && board[x, y] == board[x + xx, y + yy - 1])
                                // two in a row in centre should give higher score
                                return true;
                        }
                }
            return false;
        }
        // IS CENTRE OF THREE IN A ROW
        public static Tuple<int, int> IsCentreOfThree(GameBoard_TPL<counters> board, counters us)
        {
            int x = 0; int xx = 0; int y = 0; int yy = 0;
            for (x = 1; x <= 7; x++)
                for (y = 1; y <= 7; y++)

                    // check whether position piece at [x,y] has the same piece as neighbour
                    for (xx = 0; xx <= 1; xx++)
                        for (yy = 0; yy <= 1; yy++)


                            if (yy == 0 && xx == 0)
                                continue;
            if (board[x, y] == us &&
            board[x, y] == board[x + xx, y + yy] &&
            board[x, y] == board[x - xx, y - yy])
            {
                return new Tuple<int, int>(x - xx, y - yy);
            }


            return new Tuple<int, int>(x - xx, y - yy);
        }
        // IS CENTRE OF THREE IN A ROW
        public static Tuple<int, int> IsLeftOfThree(GameBoard_TPL<counters> board, counters us)
        {
            int x = 0; int xx = 0; int y = 0; int yy = 0;
            for (x = 1; x <= 7; x++)
                for (y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    for (xx = 0; xx <= 1; xx++)
                        for (yy = 0; yy <= 1; yy++)
                        {

                            if (yy == 0 && xx == 0)
                                continue;
                            if (board[x, y] == us &&
                            board[x, y] == board[x + xx, y + yy] &&
                            board[x, y] == board[x - xx, y - yy])
                            {
                                return new Tuple<int, int>(x - 1, y + 1);
                            }
                        }
                }
            return new Tuple<int, int>(x - 3, y - 1);
        }
        // IS CENTRE OF THREE IN A ROW
        public static Tuple<int, int> IsRightOfThree(GameBoard_TPL<counters> board, counters us)
        {
            int x = 0; int xx = 0; int y = 0; int yy = 0;
            for (x = 1; x <= 7; x++)
                for (y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    for (xx = 0; xx <= 1; xx++)
                        for (yy = 0; yy <= 1; yy++)
                        {

                            if (yy == 0 && xx == 0)
                                continue;
                            if (board[x, y] == us &&
                            board[x, y] == board[x + xx, y + yy] &&
                            board[x, y] == board[x - xx, y - yy])
                            {
                                return new Tuple<int, int>(x - 1, y - 3);
                            }
                        }
                }
            return new Tuple<int, int>(x - 1, y - 3);
        }
		
	    // -----------------------------------------------------------------------------
	    // HWL: don't think you need any of the below; should just be calling PlayGame recursively here
            if (IsOver(board, currentPlayer))
            {
                if (currentPlayer.Win(board, currentPlayer.counter))
                {
                    board.DisplayBoard();


                    if (currentPlayer.GetType() == typeof(AIPlayer_TPL))
                    {
                        int score = 0;
                        if (AIPlayer_TPL.FindThreeInARow(board, currentPlayer.counter) == true)
                        {

                            score = 1000;


                        }

                        Console.WriteLine("========================================================================================================================"
                          + Environment.NewLine + "GAME OVER! " + Environment.NewLine +
                            "------------------------------------------------------------------------------------------------------------------------" +
                            "Winner: " + currentPlayer.counter
                            + Environment.NewLine + "Score: " + score + Environment.NewLine +
                            "Positions visited: " + AIPlayer_TPL.cont + Environment.NewLine +
                            "Coordinations of winning three-in-a-row at: "
                             + Environment.NewLine + "Cell 1: " + AIPlayer_TPL.IsLeftOfThree(board, currentPlayer.counter)
                             + Environment.NewLine + "Cell 2: " + AIPlayer_TPL.IsCentreOfThree(board, currentPlayer.counter)
                             + Environment.NewLine + "Cell 3: " + AIPlayer_TPL.IsRightOfThree(board, currentPlayer.counter));


                    }
                    else
                    {
                        int score = 0;
                        if (AIPlayer_TPL.FindThreeInARow(board, otherPlayer.counter) == true)
                        {
                            score = -1000;
                        }


                        Console.WriteLine("======================================================================================================================"
                               + Environment.NewLine + "GAME OVER! " + Environment.NewLine +
                                 "------------------------------------------------------------------------------------------------------------------------" +
                                 "Winner: " + otherPlayer.counter
                                 + Environment.NewLine + "Score: " + score
                                 + Environment.NewLine + "Coordinations of winning three-in-a-row at: "
                                 + Environment.NewLine
                                 + "Cell 1: " + AIPlayer_TPL.IsLeftOfThree(board, otherPlayer.counter) + Environment.NewLine
                                 + "Cell 2: " + AIPlayer_TPL.IsCentreOfThree(board, otherPlayer.counter) + Environment.NewLine
                                 + "Cell 3: " + AIPlayer_TPL.IsRightOfThree(board, otherPlayer.counter));
                    }
                    // Stop timing.
                    stopwatch_minimax.Stop();

                    if (AIPlayer_TPL.error_confirm == 1)
                    {

                        ErrorSkip(board, currentPlayer, otherPlayer);
                    }
                    else
                    {
                        ReRun(board, currentPlayer, otherPlayer);
                    }
                    // Write result.
                    Console.WriteLine("Total elapsed for Minimax over full game execution: " + stopwatch_minimax.Elapsed + Environment.NewLine +
                            "========================================================================================================================");
                    Console.ReadLine();
                    Program.Main();
                }
                Console.WriteLine("The game is a draw.");
                Program.Main();

                if (stopMe)
                {
                    stopwatch_minimax.Stop();
                    Console.WriteLine("**HWL One move made. ");
                    Console.WriteLine("**HWL elapsed time for one move: " + stopwatch_minimax.Elapsed + Environment.NewLine + "-------------------------------------------------------");
                }
                else
                {
                    stopMe = true;
                }
            }
            PlayGame(otherPlayer, currentPlayer, ref cntr);

			-------------------------------------

			
        // DETERMINE IF Player_TPL HAS TWO
        public bool Two(GameBoard_TPL<counters> board, counters counter)
        {
            if (
                //HORIZONTAL
                (board[1, 1] == counter && board[2, 1] == counter) ||
                (board[2, 1] == counter && board[3, 1] == counter) ||
                (board[3, 1] == counter && board[4, 1] == counter) ||
                (board[4, 1] == counter && board[5, 1] == counter) ||
                (board[5, 1] == counter && board[6, 1] == counter) ||
                (board[6, 1] == counter && board[7, 1] == counter) ||
                (board[1, 2] == counter && board[2, 2] == counter) ||
                (board[2, 2] == counter && board[3, 2] == counter) ||
                (board[3, 2] == counter && board[4, 2] == counter) ||
                (board[4, 2] == counter && board[5, 2] == counter) ||
                (board[5, 2] == counter && board[6, 2] == counter) ||
                (board[6, 2] == counter && board[7, 2] == counter) ||
                (board[1, 3] == counter && board[2, 3] == counter) ||
                (board[2, 3] == counter && board[3, 3] == counter) ||
                (board[3, 3] == counter && board[4, 3] == counter) ||
                (board[4, 3] == counter && board[5, 3] == counter) ||
                (board[5, 3] == counter && board[6, 3] == counter) ||
                (board[6, 3] == counter && board[7, 3] == counter) ||
                (board[1, 4] == counter && board[2, 4] == counter) ||
                (board[2, 4] == counter && board[3, 4] == counter) ||
                (board[3, 4] == counter && board[4, 4] == counter) ||
                (board[4, 4] == counter && board[5, 4] == counter) ||
                (board[5, 4] == counter && board[6, 4] == counter) ||
                (board[6, 4] == counter && board[7, 4] == counter) ||
                (board[1, 5] == counter && board[2, 5] == counter) ||
                (board[2, 5] == counter && board[3, 5] == counter) ||
                (board[3, 5] == counter && board[4, 5] == counter) ||
                (board[4, 5] == counter && board[5, 5] == counter) ||
                (board[5, 5] == counter && board[6, 5] == counter) ||
                (board[6, 5] == counter && board[7, 5] == counter) ||
                (board[1, 6] == counter && board[2, 6] == counter) ||
                (board[2, 6] == counter && board[3, 6] == counter) ||
                (board[3, 6] == counter && board[4, 6] == counter) ||
                (board[4, 6] == counter && board[5, 6] == counter) ||
                (board[5, 6] == counter && board[6, 6] == counter) ||
                (board[6, 6] == counter && board[7, 6] == counter) ||
                (board[1, 7] == counter && board[2, 7] == counter) ||
                (board[2, 7] == counter && board[3, 7] == counter) ||
                (board[3, 7] == counter && board[4, 7] == counter) ||
                (board[4, 7] == counter && board[5, 7] == counter) ||
                (board[5, 7] == counter && board[6, 7] == counter) ||
                (board[6, 7] == counter && board[7, 7] == counter) ||
                //VERTICAL
                (board[1, 1] == counter && board[1, 2] == counter) ||
                (board[1, 2] == counter && board[1, 3] == counter) ||
                (board[1, 3] == counter && board[1, 4] == counter) ||
                (board[1, 4] == counter && board[1, 5] == counter) ||
                (board[1, 5] == counter && board[1, 6] == counter) ||
                (board[1, 6] == counter && board[1, 7] == counter) ||
                (board[2, 1] == counter && board[2, 2] == counter) ||
                (board[2, 2] == counter && board[2, 3] == counter) ||
                (board[2, 3] == counter && board[2, 4] == counter) ||
                (board[2, 4] == counter && board[2, 5] == counter) ||
                (board[2, 5] == counter && board[2, 6] == counter) ||
                (board[2, 6] == counter && board[2, 7] == counter) ||
                (board[3, 1] == counter && board[3, 2] == counter) ||
                (board[3, 2] == counter && board[3, 3] == counter) ||
                (board[3, 3] == counter && board[3, 4] == counter) ||
                (board[3, 4] == counter && board[3, 5] == counter) ||
                (board[3, 5] == counter && board[3, 6] == counter) ||
                (board[3, 6] == counter && board[3, 7] == counter) ||
                (board[4, 1] == counter && board[4, 2] == counter) ||
                (board[4, 2] == counter && board[4, 3] == counter) ||
                (board[4, 3] == counter && board[4, 4] == counter) ||
                (board[4, 4] == counter && board[4, 5] == counter) ||
                (board[4, 5] == counter && board[4, 6] == counter) ||
                (board[4, 6] == counter && board[4, 7] == counter) ||
                (board[5, 1] == counter && board[5, 2] == counter) ||
                (board[5, 2] == counter && board[5, 3] == counter) ||
                (board[5, 3] == counter && board[5, 4] == counter) ||
                (board[5, 4] == counter && board[5, 5] == counter) ||
                (board[5, 5] == counter && board[5, 6] == counter) ||
                (board[5, 6] == counter && board[5, 7] == counter) ||
                (board[6, 1] == counter && board[6, 2] == counter) ||
                (board[6, 2] == counter && board[6, 3] == counter) ||
                (board[6, 3] == counter && board[6, 4] == counter) ||
                (board[6, 4] == counter && board[6, 5] == counter) ||
                (board[6, 5] == counter && board[6, 6] == counter) ||
                (board[6, 6] == counter && board[6, 7] == counter) ||
                (board[7, 1] == counter && board[7, 2] == counter) ||
                (board[7, 2] == counter && board[7, 3] == counter) ||
                (board[7, 3] == counter && board[7, 4] == counter) ||
                (board[7, 4] == counter && board[7, 5] == counter) ||
                (board[7, 5] == counter && board[7, 6] == counter) ||
                (board[7, 6] == counter && board[7, 7] == counter) ||
                //DIAGONAL
                (board[1, 1] == counter && board[2, 2] == counter) ||
                (board[2, 2] == counter && board[3, 3] == counter) ||
                (board[3, 3] == counter && board[4, 4] == counter) ||
                (board[4, 4] == counter && board[5, 5] == counter) ||
                (board[5, 5] == counter && board[6, 6] == counter) ||
                (board[6, 6] == counter && board[7, 7] == counter) ||
                (board[1, 7] == counter && board[2, 6] == counter) ||
                (board[2, 6] == counter && board[3, 5] == counter) ||
                (board[3, 5] == counter && board[4, 4] == counter) ||
                (board[3, 5] == counter && board[2, 6] == counter) ||
                (board[2, 6] == counter && board[1, 7] == counter) ||
                (board[1, 2] == counter && board[2, 3] == counter) ||
                (board[2, 3] == counter && board[3, 4] == counter) ||
                (board[3, 4] == counter && board[4, 5] == counter) ||
                (board[4, 5] == counter && board[5, 6] == counter) ||
                (board[5, 6] == counter && board[6, 7] == counter) ||
                (board[1, 3] == counter && board[2, 4] == counter) ||
                (board[2, 4] == counter && board[3, 5] == counter) ||
                (board[3, 5] == counter && board[4, 6] == counter) ||
                (board[4, 6] == counter && board[5, 7] == counter) ||
                (board[1, 4] == counter && board[2, 5] == counter) ||
                (board[2, 5] == counter && board[3, 6] == counter) ||
                (board[3, 6] == counter && board[4, 5] == counter) ||
                (board[2, 1] == counter && board[3, 2] == counter) ||
                (board[3, 2] == counter && board[4, 3] == counter) ||
                (board[4, 3] == counter && board[5, 4] == counter) ||
                (board[5, 4] == counter && board[6, 5] == counter) ||
                (board[6, 5] == counter && board[7, 6] == counter) ||
                (board[3, 1] == counter && board[4, 2] == counter) ||
                //
                (board[4, 2] == counter && board[5, 3] == counter) ||
                (board[5, 6] == counter && board[6, 4] == counter) ||
                (board[5, 3] == counter && board[6, 4] == counter) ||
                (board[6, 4] == counter && board[7, 5] == counter) ||
                (board[4, 1] == counter && board[5, 2] == counter) ||
                (board[5, 2] == counter && board[6, 3] == counter) ||
                (board[6, 3] == counter && board[7, 1] == counter) ||
                (board[5, 1] == counter && board[6, 2] == counter) ||
                (board[6, 2] == counter && board[7, 3] == counter) ||
                (board[7, 2] == counter && board[6, 3] == counter) ||
                (board[6, 3] == counter && board[5, 4] == counter) ||
                (board[5, 4] == counter && board[4, 5] == counter) ||
                (board[4, 5] == counter && board[3, 6] == counter) ||
                (board[3, 6] == counter && board[2, 7] == counter) ||
                (board[5, 5] == counter && board[6, 5] == counter) ||
                (board[6, 5] == counter && board[7, 5] == counter) |
                (board[5, 6] == counter && board[6, 6] == counter) ||
                (board[6, 6] == counter && board[7, 6] == counter) ||
                (board[7, 3] == counter && board[6, 4] == counter) ||
                (board[6, 4] == counter && board[5, 5] == counter) ||
                (board[6, 4] == counter && board[5, 5] == counter) ||
                (board[5, 5] == counter && board[4, 6] == counter) |
                (board[5, 5] == counter && board[4, 6] == counter) ||
                (board[4, 6] == counter && board[3, 7] == counter) ||
                (board[7, 4] == counter && board[6, 5] == counter) ||
                (board[6, 5] == counter && board[5, 6] == counter) ||
                (board[5, 6] == counter && board[4, 7] == counter) ||
                (board[7, 5] == counter && board[6, 6] == counter) ||
                (board[6, 6] == counter && board[5, 7] == counter) ||
                (board[7, 7] == counter && board[6, 6] == counter) ||
                (board[6, 6] == counter && board[5, 5] == counter) ||
                (board[5, 5] == counter && board[4, 4] == counter) ||
                (board[4, 4] == counter && board[3, 3] == counter) ||
                (board[3, 3] == counter && board[2, 2] == counter) ||
                (board[2, 2] == counter && board[1, 1] == counter) ||
                (board[6, 7] == counter && board[5, 6] == counter) ||
                (board[5, 6] == counter && board[4, 5] == counter) ||
                (board[4, 5] == counter && board[3, 4] == counter) ||
                (board[3, 4] == counter && board[2, 3] == counter) ||
                (board[2, 3] == counter && board[1, 2] == counter) ||
                (board[5, 7] == counter && board[4, 6] == counter) ||
                (board[4, 6] == counter && board[3, 5] == counter) ||
                (board[3, 5] == counter && board[2, 4] == counter) ||
                (board[2, 4] == counter && board[1, 3] == counter) ||
                (board[4, 7] == counter && board[3, 6] == counter) ||
                (board[3, 6] == counter && board[2, 5] == counter) ||
                (board[2, 5] == counter && board[1, 4] == counter) ||
                (board[7, 3] == counter && board[6, 4] == counter) ||
                (board[6, 4] == counter && board[5, 2] == counter) ||
                (board[1, 6] == counter && board[2, 5] == counter) ||
                (board[2, 5] == counter && board[3, 4] == counter) ||
                (board[3, 4] == counter && board[4, 3] == counter) ||
                (board[4, 3] == counter && board[2, 5] == counter) ||
                (board[2, 5] == counter && board[1, 6] == counter) ||
                (board[1, 5] == counter && board[2, 4] == counter) ||
                (board[2, 4] == counter && board[3, 3] == counter) ||
                (board[3, 3] == counter && board[4, 2] == counter) ||
                (board[4, 2] == counter && board[5, 1] == counter) ||
                (board[1, 4] == counter && board[2, 3] == counter) ||
                (board[3, 2] == counter && board[4, 1] == counter) ||
                (board[1, 3] == counter && board[2, 2] == counter) ||
                (board[2, 2] == counter && board[3, 1] == counter) ||
                (board[7, 1] == counter && board[6, 2] == counter) ||
                (board[6, 2] == counter && board[5, 3] == counter) ||
                (board[5, 3] == counter && board[4, 4] == counter) ||
                (board[4, 4] == counter && board[3, 5] == counter) ||
                (board[3, 5] == counter && board[2, 6] == counter) ||
                (board[2, 6] == counter && board[1, 7] == counter) ||
                (board[7, 2] == counter && board[6, 3] == counter) ||
                (board[6, 3] == counter && board[5, 4] == counter) ||
                (board[5, 4] == counter && board[4, 5] == counter) ||
                (board[4, 5] == counter && board[3, 6] == counter) ||
                (board[3, 6] == counter && board[2, 7] == counter) ||
                (board[7, 3] == counter && board[6, 4] == counter) ||
                (board[6, 4] == counter && board[5, 5] == counter) ||
                (board[5, 5] == counter && board[4, 6] == counter) ||
                (board[4, 6] == counter && board[3, 7] == counter) |
                (board[7, 4] == counter && board[6, 5] == counter) ||
                (board[6, 5] == counter && board[5, 6] == counter) ||
                (board[6, 5] == counter && board[5, 6] == counter) ||
                (board[5, 6] == counter && board[4, 7] == counter) ||
                (board[7, 5] == counter && board[6, 6] == counter) ||
                (board[6, 6] == counter && board[5, 7] == counter) ||
                (board[6, 1] == counter && board[5, 2] == counter) ||
                (board[5, 2] == counter && board[4, 3] == counter) ||
                (board[4, 3] == counter && board[3, 4] == counter) ||
                (board[3, 4] == counter && board[2, 6] == counter) ||
                (board[2, 6] == counter && board[1, 7] == counter) ||
                (board[5, 1] == counter && board[4, 2] == counter) ||
                (board[4, 2] == counter && board[3, 3] == counter) ||
                (board[3, 3] == counter && board[2, 4] == counter) ||
                (board[2, 4] == counter && board[1, 3] == counter) ||
                (board[5, 7] == counter && board[4, 6] == counter) ||
                (board[4, 6] == counter && board[3, 5] == counter) ||
                (board[3, 7] == counter && board[2, 6] == counter) ||
                (board[2, 6] == counter && board[1, 5] == counter))
                return true;
            // Two at position (x,y), position (x,y), position(x,y)
            else
                One(board, counter);
                return false;
        }

        // DETERMINE IF Player_TPL HAS ONE
        public bool One(GameBoard_TPL<counters> board, counters counter)
        {
            if (
                //HORIZONTAL
                (board[1, 1] == counter) ||
                (board[1, 2] == counter) ||
                (board[1, 3] == counter) ||
                (board[1, 4] == counter) ||
                (board[1, 5] == counter) ||
                (board[1, 6] == counter) ||
                (board[1, 7] == counter) ||
                (board[2, 1] == counter) ||
                (board[2, 2] == counter) ||
                (board[2, 3] == counter) ||
                (board[2, 4] == counter) ||
                (board[2, 5] == counter) ||
                (board[2, 6] == counter) ||
                (board[2, 7] == counter) ||
                (board[3, 1] == counter) ||
                (board[3, 2] == counter) ||
                (board[3, 3] == counter) ||
                (board[3, 4] == counter) ||
                (board[3, 5] == counter) ||
                (board[3, 6] == counter) ||
                (board[3, 7] == counter) ||
                (board[4, 1] == counter) ||
                (board[4, 2] == counter) ||
                (board[4, 3] == counter) ||
                (board[4, 4] == counter) ||
                (board[4, 5] == counter) ||
                (board[4, 6] == counter) ||
                (board[4, 7] == counter) ||
                (board[5, 1] == counter) ||
                (board[5, 2] == counter) ||
                (board[5, 3] == counter) ||
                (board[5, 4] == counter) ||
                (board[5, 5] == counter) ||
                (board[5, 6] == counter) ||
                (board[5, 7] == counter) ||
                (board[6, 1] == counter) ||
                (board[6, 2] == counter) ||
                (board[6, 3] == counter) ||
                (board[6, 4] == counter) ||
                (board[6, 5] == counter) ||
                (board[6, 6] == counter) ||
                (board[6, 7] == counter) ||
                (board[7, 1] == counter) ||
                (board[7, 2] == counter) ||
                (board[7, 3] == counter) ||
                (board[7, 4] == counter) ||
                (board[7, 5] == counter) ||
                (board[7, 6] == counter) ||
                (board[7, 7] == counter))
                return true;
            // One at position (x,y), position (x,y), position(x,y)
            else
                return false;
        }

		--

		
        // IS MIDDLE CELL EMPTY
        public bool IsMiddleEmpty() {
            for (int x = 4; x <= 4; x++)
                for (int y = 4; y <= 4; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return true;
            return false;
        }

        // IS TOP LEFT CELL EMPTY
        public bool IsTopLeftEmpty()
        {
            for (int x = 1; x <= 1; x++)
                for (int y = 1; y <= 1; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return true;
            return false;
        }

        // IS TOP RIGHT CELL EMPTY
        public bool IsTopRightEmpty()
        {
            for (int x = 1; x <= 1; x++)
                for (int y = 7; y <= 7; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return true;
            return false;
        }

        // IS BOTTOM LEFT EMPTY
        public bool IsBottomLeftEmpty()
        {
            for (int x = 7; x <= 7; x++)
                for (int y = 1; y <= 1; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return true;
            return false;
        }

        // IS BOTTOM RIGHT EMPTY
        public bool IsBottomRightEmpty()
        {
            for (int x = 7; x <= 7; x++)
                for (int y = 7; y <= 7; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool IsLeftEdgesEmpty()
        {
            for (int x = 1; x <= 1; x++)
                for (int y = 2; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool IsRightEdgesEmpty()
        {
            for (int x = 7; x <= 7; x++)
                for (int y = 2; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool IsTopEdgesEmpty()
        {
            for (int x = 2; x <= 6; x++)
                for (int y = 1; y <= 1; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS CENTRE BLOCK EMPTY
        public bool IsCentreBlockEmpty()
        {
            for (int x = 3; x <= 6; x++)
                for (int y = 3; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool AreBottomEdgesEmpty()
        {
            for (int x = 2; x <= 6; x++)
                for (int y = 7; y <= 7; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool AreTopEdgesEmpty()
        {
            for (int x = 2; x <= 6; x++)
                for (int y = 1; y <= 1; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool AreLeftEdgesEmpty()
        {
            for (int x = 1; x <= 1; x++)
                for (int y = 2; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool AreRightEdgesEmpty()
        {
            for (int x = 7; x <= 7; x++)
                for (int y = 2; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }
        
        // IS EDGES EMPTY
        public bool AreInnerBottomEdgesEmpty()
        {
            for (int x = 2; x <= 6; x++)
                for (int y = 6; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool AreInnerTopEdgesEmpty()
        {
            for (int x = 2; x <= 6; x++)
                for (int y = 6; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool AreInnerLeftEdgesEmpty()
        {
            for (int x = 2; x <= 6; x++)
                for (int y = 6; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // IS EDGES EMPTY
        public bool AreInnerRightEdgesEmpty()
        {
            for (int x = 2; x <= 6; x++)
                for (int y = 6; y <= 6; y++)
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                        return false;
            return true;
        }

        // PLACE ON EDGES
        public int PlaceAtBottomEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 2; x <= 6; x++)
            for (y = 7; y <= 7; y++)
                this[x, y] = counter;
                    if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
                    {
                        
                        return -45;
                    }
                        return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtTopEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 2; x <= 6; x++)
                for (y = 1; y <= 1; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {

                return -45;
            }
            return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtLeftEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 1; x <= 1; x++)
                for (y = 2; y <= 6; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {

                return -45;
            }
            return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtRightEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 7; x <= 7; x++)
                for (y = 2; y <= 6; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {

                return -45;
            }
            return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtInnerBottomEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 2; x <= 6; x++)
                for (y = 6; y <= 6; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {

                return -15;
            }
            return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtInnerTopEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 2; x <= 6; x++)
                for (y = 6; y <= 6; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {
                return -15;
            }
            return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtInnerLeftEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 1; x <= 1; x++)
                for (y = 2; y <= 6; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {
                return -15;
            }
            return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtInnerRightEdges(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 7; x <= 7; x++)
                for (y = 2; y <= 6; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {

                return -15;
            }
            return 25;
        }

        // PLACE ON EDGES
        public int PlaceAtCentreBlock(GameBoard_TPL<T> copy, T counter)
        {
            int x = 0;
            int y = 0;
            for (x = 3; x <= 6; x++)
                for (y = 3; y <= 6; y++)
                    this[x, y] = counter;
            if (EqualityComparer<T>.Default.Equals(this[x, y], filler))
            {

                return 80;
            }
            return 25;
        }
        // IS LEFT CELL BESIDE TWO IN ROW EMPTY
        public bool IsTwoLeftNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == counters.NOUGHTS || us == counters.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x - xx, y], filler))
                            return true;
                        }
                }
            return false;
        }
        // PRINT LEFT EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintTwoLeftNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x - xx, y], filler))
                                    return new Tuple<int, int>(x - xx, y);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS RIGHT CELL BESIDE TWO IN ROW EMPTY
        public bool IsTwoRightNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x + xx + 1, y], filler))
                            return true;
                        }
                }
            return false;
        }
        // PRINT RIGHT EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintTwoRightNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x - xx, y], filler))
                                    return new Tuple<int, int>(x + xx + 1, y);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS TOP CELL BESIDE TWO IN ROW EMPTY
        public bool IsTwoTopNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x, y + yy], filler))
                            return true;
                        }
                }
            return false;
        }
        // PRINT TOP EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintTwoTopNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x, y + yy], filler))
                                    return new Tuple<int, int>(x, y + yy);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS BOTTOM CELL BESIDE TWO IN ROW EMPTY
        public bool IsTwoBottomNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x, y - yy], filler))
                            return true;
                        }
                }
            return false;
        }
        // PRINT BOTTOM EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintTwoBottomNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x, y - yy], filler))
                            return new Tuple<int, int>(x, y - yy);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS LEFT CELL BESIDE TWO IN ROW EMPTY
        public bool IsOneLeftNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x - xx, y], filler))
                                    return true;
                        }
                }
            return false;
        }
        // PRINT LEFT EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintOneLeftNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x - xx, y], filler))
                                    return new Tuple<int, int>(x - xx, y);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS RIGHT CELL BESIDE TWO IN ROW EMPTY
        public bool IsOneRightNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x + xx + 1, y], filler))
                                    return true;
                        }
                }
            return false;
        }
        // PRINT RIGHT EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintOneRightNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x - xx, y], filler))
                                    return new Tuple<int, int>(x + xx + 1, y);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS TOP CELL BESIDE TWO IN ROW EMPTY
        public bool IsOneTopNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x, y + yy], filler))
                                    return true;
                        }
                }
            return false;
        }
        // PRINT TOP EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintOneTopNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x, y + yy], filler))
                                    return new Tuple<int, int>(x, y + yy);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS BOTTOM CELL BESIDE TWO IN ROW EMPTY
        public bool IsOneBottomNeighbourEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                    // two in a row in centre should give higher score
                                    if (EqualityComparer<T>.Default.Equals(board[x, y - yy], filler))
                                    return true;
                        }
                }
            return false;
        }
        // PRINT BOTTOM EMPTY CELL BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintOneBottomNeighbour(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                           if (EqualityComparer<T>.Default.Equals(board[x, y], us))
                                    // two in a row in centre should give higher score
                                    if (EqualityComparer<T>.Default.Equals(board[x, y - yy], filler))
                                    return new Tuple<int, int>(x, y - yy);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }

        // IS THEIR GAP BETWEEN TWO IN ROW EMPTY
        public bool IsTwoWithHorziGapEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx - 1, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x + xx, y + yy], filler))
                                    return true;
                        }
                }
            return false;
        }
        // PRINT GAP BETWEEN TWO IN ROW EMPTY
        public Tuple<int, int> PrintTwoWithHorziGap(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx - 1, y + yy]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x + xx, y + yy], filler))
                                    return new Tuple<int, int>(x + xx, y + yy);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }
        // IS GAP CELL BETWEEN VERTICAL TWO IN ROW EMPTY
        public bool IsTwoWithVerticalGapEmpty(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy - 1]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x + xx, y + yy], filler))
                                    return true;
                        }
                }
            return false;
        }
        // PRINT VERTICAL GAP BESIDE TWO IN ROW EMPTY
        public Tuple<int, int> PrintTwoWithVerticalGap(GameBoard_TPL<T> board, T us)
        {
            // Debug.Assert(us == T.NOUGHTS || us == T.CROSSES);
            for (int x = 1; x <= 7; x++)
                for (int y = 1; y <= 7; y++)
                {
                    // check whether position piece at [x,y] has the same piece as neighbour
                    // Debug.Assert(board[x, y] == T.NOUGHTS || board[x, y] == T.CROSSES);
                    for (int xx = -1; xx <= 7; xx++)
                        for (int yy = -1; yy <= 7; yy++)
                        {
                            if (yy == 0 && xx == 0)
                                continue;
                            if (EqualityComparer<T>.Default.Equals(board[x, y], us) && EqualityComparer<T>.Default.Equals(board[x, y], board[x + xx, y + yy - 1]))
                                // two in a row in centre should give higher score
                                if (EqualityComparer<T>.Default.Equals(board[x + xx, y + yy], filler))
                                    return new Tuple<int, int>(x + xx, y + yy);
                        }
                }
            return new Tuple<int, int>(0, 0);
        }



		var thr1_conMoves = new List<Tuple<int, int>>
{
    Tuple.Create( 1, 7 ),
    Tuple.Create( 5, 5 ),
    Tuple.Create( 3, 3 ),
    Tuple.Create( 1, 6 )
};
                var thr2_conMoves = new List<Tuple<int, int>>
{
    Tuple.Create( 1, 7 ),
    Tuple.Create( 5, 5 ),
    Tuple.Create( 3, 3 ),
    Tuple.Create( 1, 6 )
};
                var thr3_conMoves = new List<Tuple<int, int>>
{
    Tuple.Create( 1, 7 ),
    Tuple.Create( 5, 5 ),
    Tuple.Create( 3, 3 ),
    Tuple.Create( 1, 6 )
};
                var thr4_conMoves = new List<Tuple<int, int>>
{
    Tuple.Create( 1, 7 ),
    Tuple.Create( 5, 5 ),
    Tuple.Create( 3, 3 ),
    Tuple.Create( 1, 6 )
};